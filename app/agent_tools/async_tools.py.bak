"""
å¼‚æ­¥å·¥å…·åŒ…è£…å™¨
æ”¯æŒ async generator ä¸­é—´è¿›åº¦æ¨é€
"""
import asyncio
import logging
from typing import Dict, Any, Optional, AsyncGenerator, Callable
from langchain.tools import StructuredTool
from langchain_core.tools import Tool

logger = logging.getLogger(__name__)


class AsyncProgressiveTool(StructuredTool):
    """
    å¼‚æ­¥æ¸è¿›å¼å·¥å…·åŸºç±»
    
    ç‰¹ç‚¹ï¼š
    1. æ”¯æŒ async generator yield ä¸­é—´è¿›åº¦
    2. è‡ªåŠ¨ SSE æ¨é€
    3. ä¸ LangGraph å®Œç¾é›†æˆ
    """
    
    name: str = "async_progressive_tool"
    description: str = "å¼‚æ­¥æ¸è¿›å¼å·¥å…·åŸºç±»"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
    
    async def _arun_with_progress(
        self,
        *args,
        progress_callback: Optional[Callable[[int, str], None]] = None,
        **kwargs
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """
        å¸¦è¿›åº¦æ¨é€çš„å¼‚æ­¥æ‰§è¡Œ
        
        Args:
            *args: ä½ç½®å‚æ•°
            progress_callback: è¿›åº¦å›è°ƒå‡½æ•° (progress, message) -> None
            **kwargs: å…³é”®å­—å‚æ•°
            
        Yields:
            Dict: {"type": "progress|result|error", "data": Any}
        """
        raise NotImplementedError("å­ç±»å¿…é¡»å®ç°æ­¤æ–¹æ³•")
    
    async def _arun(self, *args, **kwargs) -> Dict[str, Any]:
        """
        æ ‡å‡† LangChain å·¥å…·æ¥å£ï¼ˆæ— è¿›åº¦ï¼‰
        """
        # æ”¶é›†æ‰€æœ‰ yield çš„ç»“æœ
        results = []
        async for chunk in self._arun_with_progress(*args, **kwargs):
            results.append(chunk)
        
        # è¿”å›æœ€ç»ˆç»“æœ
        return {
            "success": True,
            "chunks": results,
            "final_result": results[-1] if results else None
        }


class AsyncHexStrikeScanner(AsyncProgressiveTool):
    """
    å¼‚æ­¥ HexStrike æ‰«æå·¥å…·ï¼ˆæ”¯æŒä¸­é—´è¿›åº¦æ¨é€ï¼‰
    """
    
    name = "async_hexstrike_scan"
    description = """å¼‚æ­¥åˆ†é˜¶æ®µå®‰å…¨æ‰«æï¼š
    
    é˜¶æ®µ1: Ping + ä¸»æœºå­˜æ´»æ£€æµ‹ï¼ˆç§’çº§ï¼‰- ç«‹å³è¿”å›
    é˜¶æ®µ2: å¿«é€Ÿç«¯å£æ‰«æï¼ˆ10-30ç§’ï¼‰- ç«‹å³è¿”å›
    é˜¶æ®µ3: å®Œæ•´æ‰«æï¼ˆåˆ†é’Ÿçº§ï¼‰- åå°æ‰§è¡Œï¼Œå¯è½®è¯¢
    
    å‚æ•°ï¼š
    - target: è¦æ‰«æçš„ç›®æ ‡ï¼ˆIP/åŸŸåï¼‰
    - user_id: ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰
    
    è¿”å›ï¼šåˆ†é˜¶æ®µç»“æœ + åå°ä»»åŠ¡ID
    """
    
    def __init__(self):
        super().__init__()
        from pydantic import BaseModel, Field
        from typing import Optional
        
        class ScanArgs(BaseModel):
            target: str = Field(..., description="è¦æ‰«æçš„ç›®æ ‡ï¼ˆIPåœ°å€æˆ–åŸŸåï¼‰")
            user_id: Optional[str] = Field(None, description="ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰")
        
        self.args_schema = ScanArgs
    
    async def _arun_with_progress(
        self,
        target: str,
        user_id: Optional[str] = None,
        progress_callback: Optional[Callable] = None,
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """
        æ‰§è¡Œåˆ†é˜¶æ®µæ‰«æï¼ˆå¸¦è¿›åº¦æ¨é€ï¼‰
        """
        from app.utils.sse_manager import SSEManager
        
        sse = SSEManager(f"user_{user_id}" if user_id else "scan_progress")
        
        # ========== é˜¶æ®µ1: Ping ==========
        yield {
            "type": "stage_start",
            "stage": "ping",
            "message": f"ğŸ“¡ æ­£åœ¨ Ping ç›®æ ‡ä¸»æœº {target}..."
        }
        if progress_callback:
            progress_callback(10, "Ping ç›®æ ‡")
        
        ping_result = await self._ping_target(target)
        
        if not ping_result["alive"]:
            yield {
                "type": "error",
                "error": f"ä¸»æœº {target} æ— å“åº”"
            }
            return
        
        yield {
            "type": "stage_complete",
            "stage": "ping",
            "result": ping_result,
            "message": f"âœ… ä¸»æœºå­˜æ´»: {target}"
        }
        if progress_callback:
            progress_callback(20, "Ping å®Œæˆ")
        
        # ========== é˜¶æ®µ2: å¿«é€Ÿæ‰«æ ==========
        yield {
            "type": "stage_start",
            "stage": "quick_scan",
            "message": f"ğŸ” æ­£åœ¨æ‰§è¡Œå¿«é€Ÿç«¯å£æ‰«æï¼ˆTop 100ï¼‰..."
        }
        if progress_callback:
            progress_callback(30, "å¼€å§‹å¿«é€Ÿæ‰«æ")
        
        quick_scan_result = await self._quick_port_scan(target, sse)
        
        open_ports = len(quick_scan_result.get("ports", []))
        yield {
            "type": "stage_complete",
            "stage": "quick_scan",
            "result": quick_scan_result,
            "message": f"âœ… å¿«é€Ÿæ‰«æå®Œæˆï¼šå‘ç° {open_ports} ä¸ªå¼€æ”¾ç«¯å£"
        }
        if progress_callback:
            progress_callback(60, f"å¿«é€Ÿæ‰«æå®Œæˆï¼Œå‘ç° {open_ports} ä¸ªç«¯å£")
        
        # ========== é˜¶æ®µ3: åˆ›å»ºåå°ä»»åŠ¡ ==========
        import uuid
        task_id = str(uuid.uuid4())
        
        yield {
            "type": "background_task_created",
            "task_id": task_id,
            "stage": "full_scan",
            "message": f"ğŸš€ å·²å¯åŠ¨åå°å®Œæ•´æ‰«æ (ä»»åŠ¡ID: {task_id})"
        }
        if progress_callback:
            progress_callback(70, "åå°æ‰«æå·²å¯åŠ¨")
        
        # åˆ›å»ºåå°æ‰«æåç¨‹
        async def full_scan_coro():
            """åå°å®Œæ•´æ‰«æåç¨‹"""
            try:
                from app.services.hexstrike_client import HexStrikeClient
                from django.conf import settings
                
                client = HexStrikeClient(
                    base_url=getattr(settings, 'HEXSTRIKE_SERVER_URL', 'http://localhost:8888'),
                    timeout=600,
                )
                
                # Nmap å®Œæ•´æ‰«æ
                sse.send_progress("nmap", 75, "æ­£åœ¨æ‰§è¡Œ Nmap å®Œæ•´æ‰«æ...")
                nmap_result = client.run_command("nmap_scan", {
                    "target": target,
                    "-sV": True,
                    "-O": True,
                })
                
                # Nuclei æ¼æ´æ‰«æ
                sse.send_progress("nuclei", 85, "æ­£åœ¨æ‰§è¡Œ Nuclei æ¼æ´æ‰«æ...")
                nuclei_result = client.run_command("nuclei_scan", {
                    "target": target,
                    "severity": "critical,high,medium",
                })
                
                # ç”Ÿæˆ PDF æŠ¥å‘Š
                sse.send_progress("report", 95, "æ­£åœ¨ç”Ÿæˆ PDF æŠ¥å‘Š...")
                from app.services.hexstrike_pdf_reporter import HexStrikePDFReporter
                reporter = HexStrikePDFReporter()
                pdf_file = reporter.generate_pdf_report(
                    target=target,
                    nmap_results=nmap_result.get("data"),
                    nuclei_results=nuclei_result.get("data"),
                )
                
                sse.send_progress("complete", 100, "âœ… å®Œæ•´æ‰«æå®Œæˆï¼")
                
                return {
                    "success": True,
                    "nmap": nmap_result.get("data"),
                    "nuclei": nuclei_result.get("data"),
                    "pdf_file": pdf_file,
                }
                
            except Exception as e:
                logger.error(f"[full_scan_coro] æ‰«æå¤±è´¥: {e}", exc_info=True)
                sse.send_error(f"æ‰«æå¤±è´¥: {str(e)}", "full_scan")
                return {"success": False, "error": str(e)}
        
        # æ³¨å†Œåˆ°ä»»åŠ¡ç®¡ç†å™¨
        from app.agent_graphs.security_scan_graph import async_task_manager
        async_task_manager.create_task(full_scan_coro(), task_id, "full_scan")
        
        # è¿”å›ç»“æœ
        yield {
            "type": "complete",
            "task_id": task_id,
            "quick_scan_result": quick_scan_result,
            "final_message": f"âœ… å¿«é€Ÿè¯„ä¼°å®Œæˆï¼Œåå°æ‰«æå·²å¯åŠ¨ (ä»»åŠ¡ID: {task_id})"
        }
        if progress_callback:
            progress_callback(100, "æ‰€æœ‰é˜¶æ®µå®Œæˆ")
    
    async def _ping_target(self, target: str) -> Dict[str, Any]:
        """Ping ç›®æ ‡ä¸»æœº"""
        try:
            proc = await asyncio.create_subprocess_exec(
                "ping", "-c", "1", "-W", "3", target,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await proc.communicate()
            
            return {
                "alive": proc.returncode == 0,
                "output": stdout.decode(),
                "target": target
            }
        except Exception as e:
            logger.error(f"[ping_target] å¤±è´¥: {e}")
            return {"alive": False, "output": str(e), "target": target}
    
    async def _quick_port_scan(
        self,
        target: str,
        sse
    ) -> Dict[str, Any]:
        """å¿«é€Ÿç«¯å£æ‰«æ"""
        import time
        start_time = time.time()
        
        # å°è¯•ä½¿ç”¨ HexStrike
        try:
            from app.services.hexstrike_client import HexStrikeClient
            from django.conf import settings
            
            client = HexStrikeClient(
                base_url=getattr(settings, 'HEXSTRIKE_SERVER_URL', 'http://localhost:8888'),
                timeout=60,
            )
            
            nmap_result = client.run_command("nmap_scan", {
                "target": target,
                "-F": True,
                "-T4": True,
            })
            
            if nmap_result.get("success"):
                ports = self._parse_nmap_ports(nmap_result["data"].get("stdout", ""))
                return {
                    "ports": ports,
                    "scan_time": time.time() - start_time,
                    "raw_output": nmap_result["data"].get("stdout", "")
                }
        except Exception as e:
            logger.warning(f"HexStrike å¿«é€Ÿæ‰«æå¤±è´¥: {e}ï¼Œä½¿ç”¨æœ¬åœ° nmap")
        
        # å›é€€åˆ°æœ¬åœ° nmap
        try:
            proc = await asyncio.create_subprocess_exec(
                "nmap", "-F", "-T4", "-oX", "-", target,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60.0)
            
            ports = self._parse_nmap_ports(stdout.decode())
            return {
                "ports": ports,
                "scan_time": time.time() - start_time,
                "raw_output": stdout.decode()
            }
        except Exception as e:
            logger.error(f"æœ¬åœ° nmap å¤±è´¥: {e}")
            return {"ports": [], "scan_time": 0, "error": str(e)}
    
    def _parse_nmap_ports(self, stdout: str) -> list:
        """è§£æ nmap ç«¯å£"""
        import re
        ports = []
        pattern = re.compile(r'portid="(\d+)".*?state="(\w+)"')
        
        for match in pattern.finditer(stdout):
            port_num = match.group(1)
            state = match.group(2)
            
            if state == "open":
                ports.append({
                    "port": port_num,
                    "protocol": "tcp",
                    "state": state
                })
        
        return ports


# å·¥å…·å®ä¾‹
async_hexstrike_scan_tool = AsyncHexStrikeScanner()
