"""
修复漏洞数据中的组件名称和版本信息错误
将错误的affected_component和affected_versions字段分开
"""
import re
from django.core.management.base import BaseCommand
from app.models import Vulnerability


class Command(BaseCommand):
    help = '修复漏洞数据中的组件名称和版本信息错误'

    def add_arguments(self, parser):
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='仅显示将要修复的记录，不实际修改'
        )
        parser.add_argument(
            '--cve-id',
            type=str,
            help='只修复指定的CVE编号'
        )

    def handle(self, *args, **options):
        dry_run = options['dry_run']
        cve_id = options.get('cve_id')
        
        # 查找需要修复的漏洞
        vulnerabilities = Vulnerability.objects.all()
        if cve_id:
            vulnerabilities = vulnerabilities.filter(cve_id=cve_id)
        
        fixed_count = 0
        skipped_count = 0
        error_count = 0
        
        self.stdout.write('开始扫描漏洞数据...')
        self.stdout.write('-' * 80)
        
        for vuln in vulnerabilities:
            if not vuln.content or not isinstance(vuln.content, dict):
                continue
            
            content = vuln.content.copy()
            affected_component = content.get('affected_component', '').strip()
            affected_versions = content.get('affected_versions', '').strip()
            
            # 检查是否需要修复
            needs_fix = False
            
            # 情况1: affected_component包含版本号（如"before 2.2.1"）
            if affected_component and self._looks_like_version(affected_component):
                needs_fix = True
            
            # 情况2: affected_versions包含组件名称（如"Apache Struts ..."）
            if affected_versions and self._contains_component_name(affected_versions):
                needs_fix = True
            
            # 情况3: affected_component是无效的组件名称（如"this"、"two heap"、"XXE vulnerability"等）
            if affected_component and self._is_invalid_component_name(affected_component):
                needs_fix = True
            
            # 情况3: affected_component是无效的组件名称（如"this", "two heap", "XXE vulnerability"等）
            if affected_component and self._is_invalid_component_name(affected_component):
                needs_fix = True
            
            if not needs_fix:
                skipped_count += 1
                continue
            
            # 尝试修复
            try:
                new_component, new_versions = self._fix_component_and_versions(
                    affected_component, affected_versions, vuln
                )
                
                if new_component != affected_component or new_versions != affected_versions:
                    self.stdout.write(f'\nCVE: {vuln.cve_id}')
                    self.stdout.write(f'  原 affected_component: {affected_component}')
                    self.stdout.write(f'  新 affected_component: {new_component}')
                    self.stdout.write(f'  原 affected_versions: {affected_versions[:100]}...' if len(affected_versions) > 100 else f'  原 affected_versions: {affected_versions}')
                    self.stdout.write(f'  新 affected_versions: {new_versions[:100]}...' if len(new_versions) > 100 else f'  新 affected_versions: {new_versions}')
                    
                    if not dry_run:
                        content['affected_component'] = new_component
                        content['affected_versions'] = new_versions
                        vuln.content = content
                        vuln.save(update_fields=['content'])
                        self.stdout.write(self.style.SUCCESS('  ✓ 已修复'))
                    else:
                        self.stdout.write(self.style.WARNING('  [DRY RUN] 将修复'))
                    
                    fixed_count += 1
                else:
                    skipped_count += 1
                    
            except Exception as e:
                self.stdout.write(self.style.ERROR(f'\n修复 {vuln.cve_id} 时出错: {str(e)}'))
                error_count += 1
        
        self.stdout.write('-' * 80)
        self.stdout.write(f'\n修复完成:')
        self.stdout.write(f'  修复: {fixed_count} 条')
        self.stdout.write(f'  跳过: {skipped_count} 条')
        self.stdout.write(f'  错误: {error_count} 条')
        
        if dry_run:
            self.stdout.write(self.style.WARNING('\n这是模拟运行，没有实际修改数据。使用 --no-dry-run 执行实际修复。'))
    
    def _looks_like_version(self, text: str) -> bool:
        """检查文本是否看起来像版本号"""
        # 检查是否包含版本号模式
        version_patterns = [
            r'\d+\.\d+',  # 如 2.2.1
            r'before\s+\d+',  # 如 before 2.2.1
            r'through\s+',  # 如 through 6.1.0
            r'<\s*\d+',  # 如 < 3.13.3
            r'<=\s*\d+',  # 如 <= 3.13.3
            r'>\s*\d+',  # 如 > 3.13.3
            r'>=\s*\d+',  # 如 >= 3.13.3
        ]
        
        for pattern in version_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return True
        
        # 如果只包含数字和常见版本关键词，可能是版本信息
        if re.match(r'^[\d\s<>=beforethrough]+$', text, re.IGNORECASE):
            return True
        
        return False
    
    def _contains_component_name(self, text: str) -> bool:
        """检查文本是否包含组件名称（通常是大写字母开头的单词）"""
        # 如果包含类似"Apache"、"Apache Struts"等组件名称模式
        component_patterns = [
            r'[A-Z][a-z]+\s+[A-Z][a-z]+',  # 如 Apache Struts
            r'\([a-z]+\.[a-z]+:',  # 如 (com.opensymphony:xwork)
        ]
        
        for pattern in component_patterns:
            if re.search(pattern, text):
                return True
        
        return False
    
    def _is_invalid_component_name(self, component: str) -> bool:
        """检查组件名称是否是无效的（如"this", "two heap", "XXE vulnerability"等）"""
        if not component:
            return False
        
        component_lower = component.lower().strip()
        
        # 无效组件名称模式
        invalid_patterns = [
            r'^(this|that|these|those)$',  # 代词
            r'^(two|three|four|five|six|seven|eight|nine|ten)\s+',  # 数字开头的描述
            r'^(heap|stack|buffer|memory|vulnerability|issue|bug|problem|error)$',  # 通用技术词汇
            r'^(xxe|xss|csrf|sql\s*injection|rce|rfi|lfi)',  # 漏洞类型
            r'^(before|after|through|to|until|up\s+to|from)',  # 版本范围关键词
            r'^[<>=]+\s*\d+',  # 版本比较符
            r'^\d+\.\d+',  # 版本号开头
            r'^[\d\s<>=beforethrough]+$',  # 只包含版本相关字符
        ]
        
        import re
        for pattern in invalid_patterns:
            if re.match(pattern, component_lower, re.IGNORECASE):
                return True
        
        # 如果组件名称太短（少于3个字符）或只包含常见英文单词，可能是无效的
        if len(component_lower) < 3:
            return True
        
        # 检查是否是常见的无效组件名称
        invalid_names = [
            'this', 'that', 'these', 'those',
            'two heap', 'heap', 'stack', 'buffer',
            'xxe vulnerability', 'vulnerability', 'issue', 'bug',
            'before', 'after', 'through'
        ]
        if component_lower in invalid_names:
            return True
        
        return False
    
    def _fix_component_and_versions(self, component: str, versions: str, vuln=None) -> tuple:
        """
        修复组件名称和版本信息
        
        Returns:
            tuple: (new_component, new_versions)
        """
        new_component = component
        new_versions = versions
        
        # 情况1: component是版本信息，versions包含组件名称
        if self._looks_like_version(component) and self._contains_component_name(versions):
            # 从versions中提取组件名称
            extracted_component = self._extract_component_from_versions(versions)
            if extracted_component:
                new_component = extracted_component
                # 清理versions，移除组件名称，只保留版本范围
                new_versions = self._clean_versions(versions)
        
        # 情况2: component是版本信息，但versions不包含组件名称
        elif self._looks_like_version(component):
            # 将component的内容移到versions
            if versions:
                new_versions = f"{versions}\n{component}"
            else:
                new_versions = component
            new_component = ""  # 无法确定组件名称，留空
        
        # 情况3: component正常，但versions包含组件名称
        elif self._contains_component_name(versions) and not self._looks_like_version(component):
            # 清理versions，移除组件名称
            new_versions = self._clean_versions(versions)
            # 如果component为空或无效，尝试从versions中提取
            if not component or self._is_invalid_component_name(component):
                extracted_component = self._extract_component_from_versions(versions)
                if extracted_component:
                    new_component = extracted_component
        
        # 情况4: component是无效的组件名称，但versions包含组件名称
        elif self._is_invalid_component_name(component) and self._contains_component_name(versions):
            # 从versions中提取组件名称
            extracted_component = self._extract_component_from_versions(versions)
            if extracted_component:
                new_component = extracted_component
            # 清理versions，移除组件名称
            new_versions = self._clean_versions(versions)
        
        # 情况5: component是无效的组件名称，但versions不包含组件名称
        elif self._is_invalid_component_name(component):
            # 如果提供了vulnerability对象，尝试从title或description中提取组件名称
            if vuln:
                extracted = self._extract_component_from_text(vuln.title or '')
                if not extracted and vuln.description:
                    extracted = self._extract_component_from_text(vuln.description[:500])
                if extracted:
                    new_component = extracted
                else:
                    new_component = ""  # 无法确定组件名称，留空
            else:
                new_component = ""  # 无法确定组件名称，留空
        
        return new_component, new_versions
    
    def _extract_component_from_versions(self, versions: str) -> str:
        """从versions字符串中提取组件名称"""
        # 尝试提取第一个出现的组件名称
        # 例如: "- Apache Struts (com.opensymphony:xwork) 2.0.0 before 2.2.1"
        # 提取: "Apache Struts"
        
        lines = versions.split('\n')
        components = []
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('-'):
                line = line.lstrip('-').strip()
            
            # 提取组件名称（通常是大写字母开头的单词序列）
            # 匹配 "Apache Struts" 或 "Apache" 等
            match = re.search(r'([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)', line)
            if match:
                component = match.group(1)
                # 过滤掉明显的版本号
                if not self._looks_like_version(component):
                    # 过滤掉明显的非组件名称（如"this"、"two"、"XXE"等）
                    component_lower = component.lower()
                    invalid_components = ['this', 'that', 'these', 'those', 'two', 'three', 'four', 'five',
                                        'xxe', 'heap', 'stack', 'buffer', 'overflow', 'vulnerability', 
                                        'issue', 'bug', 'problem', 'error', 'before', 'after', 'through']
                    if component_lower not in invalid_components and not any(inv in component_lower for inv in ['vulnerability', 'issue', 'bug']):
                        components.append(component)
        
        # 返回最常见的组件名称（通常是第一个）
        if components:
            # 去重，但保持顺序
            seen = set()
            unique_components = []
            for comp in components:
                if comp not in seen:
                    seen.add(comp)
                    unique_components.append(comp)
            
            # 如果有多个组件，返回主组件名称（通常是第一个）
            return unique_components[0] if unique_components else ""
        
        return ""
    
    def _clean_versions(self, versions: str) -> str:
        """清理versions字符串，移除组件名称，只保留版本范围"""
        lines = versions.split('\n')
        cleaned_lines = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # 移除行首的 "- " 或 "-"
            if line.startswith('-'):
                line = line.lstrip('-').strip()
            
            # 移除组件名称部分（通常在大写字母开头到括号或版本号之前）
            # 例如: "Apache Struts (com.opensymphony:xwork) 2.0.0 before 2.2.1"
            # 变成: "2.0.0 before 2.2.1"
            
            # 尝试匹配版本范围模式
            version_pattern = r'(\d+\.\d+(?:\.\d+)?(?:\s+(?:before|through|to)\s+(?:<[=>]?\s*)?\d+\.\d+(?:\.\d+)?)?|<[=>]?\s*\d+\.\d+(?:\.\d+)?|>\s*=\s*\d+\.\d+(?:\.\d+)?)'
            match = re.search(version_pattern, line)
            if match:
                cleaned_line = match.group(1)
                cleaned_lines.append(cleaned_line)
            else:
                # 如果没有匹配到版本模式，保留原行（可能已经是清理过的）
                cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines)

