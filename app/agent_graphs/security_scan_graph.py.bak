"""
åŸºäº LangGraph çš„å®‰å…¨æ‰«æå·¥ä½œæµ
ä½¿ç”¨ Redis Checkpointer å®ç°çŠ¶æ€æŒä¹…åŒ–å’Œå¼‚æ­¥ä»»åŠ¡ç®¡ç†
"""
import asyncio
import logging
import uuid
from typing import Dict, Any, Optional, TypedDict, Literal
from datetime import datetime
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
from langchain_core.runnables import RunnableConfig
from django.conf import settings

logger = logging.getLogger(__name__)


class ScanState(TypedDict):
    """æ‰«æå·¥ä½œæµçŠ¶æ€"""
    # è¾“å…¥
    target: str
    user_id: Optional[str]
    
    # é˜¶æ®µç»“æœ
    ping_result: Optional[Dict[str, Any]]
    quick_scan_result: Optional[Dict[str, Any]]
    full_scan_result: Optional[Dict[str, Any]]
    
    # ä»»åŠ¡ç®¡ç†
    current_stage: Literal[
        "init",           # åˆå§‹åŒ–
        "ping",           # Ping æ£€æµ‹
        "quick_scan",     # å¿«é€Ÿæ‰«æ
        "full_scan",      # å®Œæ•´æ‰«æ
        "polling",        # è½®è¯¢åå°ä»»åŠ¡
        "complete",       # å®Œæˆ
        "failed"          # å¤±è´¥
    ]
    
    # å¼‚æ­¥ä»»åŠ¡
    background_tasks: Dict[str, Any]  # {task_id: {"future": Future, "stage": str}}
    
    # è¿›åº¦è·Ÿè¸ª
    progress: int  # 0-100
    progress_messages: list
    
    # æœ€ç»ˆç»“æœ
    final_result: Optional[Dict[str, Any]]
    error: Optional[str]


class AsyncTaskManager:
    """
    å¼‚æ­¥ä»»åŠ¡ç®¡ç†å™¨
    ç®¡ç† langgraph å·¥ä½œæµä¸­çš„åå°ä»»åŠ¡
    """
    
    def __init__(self):
        self.tasks: Dict[str, asyncio.Task] = {}
    
    def create_task(
        self,
        coro,
        task_id: str,
        stage: str
    ) -> str:
        """
        åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        
        Args:
            coro: åç¨‹å¯¹è±¡
            task_id: ä»»åŠ¡ID
            stage: é˜¶æ®µåç§°
            
        Returns:
            task_id
        """
        task = asyncio.create_task(coro)
        self.tasks[task_id] = {
            "task": task,
            "stage": stage,
            "created_at": datetime.now(),
        }
        logger.info(f"[AsyncTaskManager] åˆ›å»ºä»»åŠ¡: {task_id} ({stage})")
        return task_id
    
    async def get_task_result(self, task_id: str, timeout: float = 0.1):
        """
        è·å–ä»»åŠ¡ç»“æœï¼ˆéé˜»å¡ï¼‰
        
        Args:
            task_id: ä»»åŠ¡ID
            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            
        Returns:
            (done: bool, result: Any)
        """
        if task_id not in self.tasks:
            return False, None
        
        task_info = self.tasks[task_id]
        task = task_info["task"]
        
        if task.done():
            try:
                result = await asyncio.wait_for(task, timeout=timeout)
                logger.info(f"[AsyncTaskManager] ä»»åŠ¡å®Œæˆ: {task_id}")
                # æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡
                del self.tasks[task_id]
                return True, result
            except Exception as e:
                logger.error(f"[AsyncTaskManager] ä»»åŠ¡å¤±è´¥: {task_id}, {e}")
                del self.tasks[task_id]
                return True, {"error": str(e)}
        
        return False, None
    
    def get_all_active_tasks(self) -> Dict[str, str]:
        """è·å–æ‰€æœ‰æ´»è·ƒä»»åŠ¡"""
        return {
            task_id: info["stage"]
            for task_id, info in self.tasks.items()
            if not info["task"].done()
        }


# å…¨å±€ä»»åŠ¡ç®¡ç†å™¨
async_task_manager = AsyncTaskManager()


# ==================== èŠ‚ç‚¹å®ç° ====================

async def node_init(state: ScanState) -> ScanState:
    """
    åˆå§‹åŒ–èŠ‚ç‚¹
    å‡†å¤‡æ‰«æå‚æ•°ï¼Œåˆå§‹åŒ–çŠ¶æ€
    """
    target = state["target"]
    user_id = state.get("user_id")
    
    logger.info(f"[node_init] å¼€å§‹å¤„ç†ç›®æ ‡: {target}")
    
    state["current_stage"] = "init"
    state["progress"] = 0
    state["progress_messages"] = []
    state["background_tasks"] = {}
    state["final_result"] = None
    state["error"] = None
    
    # æ¨é€è¿›åº¦
    from app.utils.sse_manager import SSEManager
    sse = SSEManager(f"user_{user_id}" if user_id else "scan_progress")
    sse.send_progress("init", 0, f"ğŸš€ å¼€å§‹å¯¹ {target} è¿›è¡Œå®‰å…¨è¯„ä¼°")
    
    return state


async def node_ping(state: ScanState) -> ScanState:
    """
    Ping èŠ‚ç‚¹ï¼ˆé˜¶æ®µ1ï¼‰
    æ£€æµ‹ä¸»æœºå­˜æ´»
    """
    target = state["target"]
    user_id = state.get("user_id")
    
    logger.info(f"[node_ping] Ping ç›®æ ‡: {target}")
    state["current_stage"] = "ping"
    
    # æ¨é€è¿›åº¦
    from app.utils.sse_manager import SSEManager
    sse = SSEManager(f"user_{user_id}" if user_id else "scan_progress")
    sse.send_progress("ping", 10, f"ğŸ“¡ æ­£åœ¨ Ping ç›®æ ‡ä¸»æœº {target}...")
    
    # æ‰§è¡Œ Ping
    proc = await asyncio.create_subprocess_exec(
        "ping", "-c", "1", "-W", "3", target,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate()
    
    ping_result = {
        "alive": proc.returncode == 0,
        "output": stdout.decode(),
        "target": target
    }
    
    state["ping_result"] = ping_result
    state["progress"] = 20
    
    if ping_result["alive"]:
        sse.send_progress("ping", 20, f"âœ… ä¸»æœºå­˜æ´»: {target} å“åº”æ­£å¸¸")
        state["progress_messages"].append("âœ… ä¸»æœºå­˜æ´»æ£€æµ‹å®Œæˆ")
        logger.info(f"[node_ping] ä¸»æœºå­˜æ´»: {target}")
    else:
        sse.send_error(f"ä¸»æœºæ— å“åº”: {target}", "ping")
        state["current_stage"] = "failed"
        state["error"] = f"ä¸»æœº {target} æ— å“åº”"
        logger.warning(f"[node_ping] ä¸»æœºæ— å“åº”: {target}")
    
    return state


async def node_quick_scan(state: ScanState) -> ScanState:
    """
    å¿«é€Ÿæ‰«æèŠ‚ç‚¹ï¼ˆé˜¶æ®µ2ï¼‰
    æ‰§è¡Œ Top 100 ç«¯å£æ‰«æ
    """
    target = state["target"]
    user_id = state.get("user_id")
    
    logger.info(f"[node_quick_scan] å¿«é€Ÿæ‰«æ: {target}")
    state["current_stage"] = "quick_scan"
    
    # æ¨é€è¿›åº¦
    from app.utils.sse_manager import SSEManager
    sse = SSEManager(f"user_{user_id}" if user_id else "scan_progress")
    sse.send_progress("quick_scan", 30, f"ğŸ” æ­£åœ¨æ‰§è¡Œå¿«é€Ÿç«¯å£æ‰«æï¼ˆTop 100ï¼‰...")
    
    # ä½¿ç”¨ HexStrike æˆ–æœ¬åœ° nmap
    try:
        from app.services.hexstrike_client import HexStrikeClient
        client = HexStrikeClient(
            base_url=getattr(settings, 'HEXSTRIKE_SERVER_URL', 'http://localhost:8888'),
            timeout=60,
        )
        
        # å¿«é€Ÿ Nmap æ‰«æ
        nmap_result = client.run_command("nmap_scan", {
            "target": target,
            "-F": True,  # å¿«é€Ÿæ‰«æ
            "-T4": True,
        })
        
        if nmap_result.get("success"):
            ports = _parse_nmap_ports(nmap_result["data"].get("stdout", ""))
            quick_scan_result = {
                "ports": ports,
                "scan_time": nmap_result["data"].get("scan_time", 0),
                "raw_output": nmap_result["data"].get("stdout", "")
            }
        else:
            # å›é€€åˆ°æœ¬åœ° nmap
            quick_scan_result = await _quick_scan_local(target)
            
    except Exception as e:
        logger.error(f"[node_quick_scan] HexStrike å¤±è´¥: {e}ï¼Œä½¿ç”¨æœ¬åœ° nmap")
        quick_scan_result = await _quick_scan_local(target)
    
    state["quick_scan_result"] = quick_scan_result
    state["progress"] = 60
    
    open_ports = len(quick_scan_result.get("ports", []))
    sse.send_progress(
        "quick_scan",
        60,
        f"âœ… å¿«é€Ÿæ‰«æå®Œæˆï¼šå‘ç° {open_ports} ä¸ªå¼€æ”¾ç«¯å£"
    )
    state["progress_messages"].append(f"âœ… å¿«é€Ÿæ‰«æå®Œæˆï¼Œå‘ç° {open_ports} ä¸ªç«¯å£")
    
    logger.info(f"[node_quick_scan] å®Œæˆ: å‘ç° {open_ports} ä¸ªç«¯å£")
    
    return state


async def node_dispatch_full_scan(state: ScanState) -> ScanState:
    """
    Dispatcher èŠ‚ç‚¹ï¼ˆé˜¶æ®µ3ï¼‰
    å¼‚æ­¥å‘èµ·å®Œæ•´æ‰«æä»»åŠ¡ï¼Œç«‹å³è¿”å›ä»»åŠ¡ID
    """
    target = state["target"]
    user_id = state.get("user_id")
    
    logger.info(f"[node_dispatch_full_scan] åˆ†å‘å®Œæ•´æ‰«æä»»åŠ¡: {target}")
    state["current_stage"] = "full_scan"
    
    # æ¨é€è¿›åº¦
    from app.utils.sse_manager import SSEManager
    sse = SSEManager(f"user_{user_id}" if user_id else "scan_progress")
    sse.send_progress("dispatch", 70, "ğŸš€ æ­£åœ¨å¯åŠ¨åå°å®Œæ•´æ‰«æ...")
    
    # åˆ›å»ºåå°ä»»åŠ¡ID
    task_id = str(uuid.uuid4())
    
    # å®šä¹‰åå°æ‰«æåç¨‹
    async def full_scan_coro():
        """å®Œæ•´æ‰«æåç¨‹"""
        try:
            from app.services.hexstrike_client import HexStrikeClient
            client = HexStrikeClient(timeout=600)
            
            # Nmap å®Œæ•´æ‰«æ
            sse.send_progress("nmap", 75, "æ­£åœ¨æ‰§è¡Œ Nmap å®Œæ•´æ‰«æ...")
            nmap_result = client.run_command("nmap_scan", {
                "target": target,
                "-sV": True,
                "-O": True,
            })
            
            # Nuclei æ¼æ´æ‰«æ
            sse.send_progress("nuclei", 85, "æ­£åœ¨æ‰§è¡Œ Nuclei æ¼æ´æ‰«æ...")
            nuclei_result = client.run_command("nuclei_scan", {
                "target": target,
                "severity": "critical,high,medium",
            })
            
            # ç”Ÿæˆ PDF æŠ¥å‘Š
            sse.send_progress("report", 95, "æ­£åœ¨ç”Ÿæˆ PDF æŠ¥å‘Š...")
            from app.services.hexstrike_pdf_reporter import HexStrikePDFReporter
            reporter = HexStrikePDFReporter()
            pdf_file = reporter.generate_pdf_report(
                target=target,
                nmap_results=nmap_result.get("data"),
                nuclei_results=nuclei_result.get("data"),
            )
            
            sse.send_progress("complete", 100, "âœ… å®Œæ•´æ‰«æå®Œæˆï¼")
            
            return {
                "success": True,
                "nmap": nmap_result.get("data"),
                "nuclei": nuclei_result.get("data"),
                "pdf_file": pdf_file,
            }
            
        except Exception as e:
            logger.error(f"[full_scan_coro] æ‰«æå¤±è´¥: {e}", exc_info=True)
            sse.send_error(f"æ‰«æå¤±è´¥: {str(e)}", "full_scan")
            return {"success": False, "error": str(e)}
    
    # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
    async_task_manager.create_task(
        full_scan_coro(),
        task_id,
        "full_scan"
    )
    
    # ä¿å­˜ä»»åŠ¡IDåˆ°state
    state["background_tasks"][task_id] = {
        "stage": "full_scan",
        "created_at": datetime.now().isoformat()
    }
    
    state["progress"] = 70
    sse.send_progress(
        "dispatched",
        70,
        f"âœ… åå°æ‰«æå·²å¯åŠ¨ (ä»»åŠ¡ID: {task_id})"
    )
    state["progress_messages"].append(f"âœ… åå°æ‰«æä»»åŠ¡å·²å¯åŠ¨: {task_id}")
    
    logger.info(f"[node_dispatch_full_scan] ä»»åŠ¡å·²åˆ†å‘: {task_id}")
    
    return state


async def node_poll(state: ScanState) -> ScanState:
    """
    Checker èŠ‚ç‚¹ï¼ˆè½®è¯¢ï¼‰
    æ£€æŸ¥åå°ä»»åŠ¡çŠ¶æ€ï¼Œå®Œæˆåæ›´æ–°ç»“æœ
    """
    target = state["target"]
    user_id = state.get("user_id")
    background_tasks = state.get("background_tasks", {})
    
    logger.info(f"[node_poll] è½®è¯¢ä»»åŠ¡çŠ¶æ€: {len(background_tasks)} ä¸ªä»»åŠ¡")
    state["current_stage"] = "polling"
    
    # æ¨é€è¿›åº¦
    from app.utils.sse_manager import SSEManager
    sse = SSEManager(f"user_{user_id}" if user_id else "scan_progress")
    
    # æ£€æŸ¥æ‰€æœ‰åå°ä»»åŠ¡
    all_done = True
    results = {}
    
    for task_id, task_info in background_tasks.items():
        done, result = await async_task_manager.get_task_result(task_id)
        
        if done:
            # ä»»åŠ¡å®Œæˆ
            if result and result.get("success"):
                sse.send_progress("task_complete", 100, f"âœ… ä»»åŠ¡ {task_id} å®Œæˆ")
                results[task_id] = result
                logger.info(f"[node_poll] ä»»åŠ¡å®Œæˆ: {task_id}")
            else:
                error = result.get("error", "æœªçŸ¥é”™è¯¯") if result else "ä»»åŠ¡æ— ç»“æœ"
                sse.send_error(f"ä»»åŠ¡ {task_id} å¤±è´¥: {error}", "poll")
                state["error"] = error
                state["current_stage"] = "failed"
                return state
        else:
            # ä»»åŠ¡ä»åœ¨è¿è¡Œ
            all_done = False
            logger.debug(f"[node_poll] ä»»åŠ¡è¿è¡Œä¸­: {task_id}")
    
    if all_done:
        # æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        state["current_stage"] = "complete"
        state["progress"] = 100
        state["final_result"] = results
        
        # æ¨é€å®Œæˆé€šçŸ¥
        sse.send_complete({
            "message": "âœ… æ‰€æœ‰æ‰«æä»»åŠ¡å®Œæˆï¼",
            "target": target,
            "results": results
        })
        
        logger.info(f"[node_poll] æ‰€æœ‰ä»»åŠ¡å®Œæˆ: {target}")
    else:
        # ä»æœ‰ä»»åŠ¡åœ¨è¿è¡Œï¼Œç»§ç»­è½®è¯¢
        state["progress"] = min(state["progress"] + 5, 95)
        sse.send_progress("polling", state["progress"], "â³ åå°æ‰«æè¿›è¡Œä¸­...")
        logger.info(f"[node_poll] ä»æœ‰ä»»åŠ¡è¿è¡Œï¼Œç»§ç»­è½®è¯¢")
    
    return state


# ==================== æ¡ä»¶è¾¹ ====================

def should_poll(state: ScanState) -> bool:
    """åˆ¤æ–­æ˜¯å¦éœ€è¦è½®è¯¢"""
    return len(state.get("background_tasks", {})) > 0


def should_continue_polling(state: ScanState) -> Literal["poll", "end"]:
    """åˆ¤æ–­æ˜¯å¦ç»§ç»­è½®è¯¢"""
    if state["current_stage"] == "complete":
        return "end"
    elif state["current_stage"] == "failed":
        return "end"
    else:
        return "poll"


def is_ping_successful(state: ScanState) -> bool:
    """åˆ¤æ–­ Ping æ˜¯å¦æˆåŠŸ"""
    return state.get("ping_result", {}).get("alive", False)


# ==================== å·¥å…·å‡½æ•° ====================

def _parse_nmap_ports(stdout: str) -> list:
    """ä» nmap è¾“å‡ºä¸­è§£æå¼€æ”¾ç«¯å£"""
    import re
    ports = []
    pattern = re.compile(r'portid="(\d+)".*?state="(\w+)"')
    
    for match in pattern.finditer(stdout):
        port_num = match.group(1)
        state = match.group(2)
        
        if state == "open":
            ports.append({
                "port": port_num,
                "protocol": "tcp",
                "state": state
            })
    
    return ports


async def _quick_scan_local(target: str) -> Dict[str, Any]:
    """æœ¬åœ°å¿«é€Ÿç«¯å£æ‰«æï¼ˆå›é€€æ–¹æ¡ˆï¼‰"""
    try:
        proc = await asyncio.create_subprocess_exec(
            "nmap", "-F", "-T4", "-oX", "-", target,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60.0)
        
        ports = _parse_nmap_ports(stdout.decode())
        
        return {
            "ports": ports,
            "scan_time": 0,
            "raw_output": stdout.decode()
        }
    except Exception as e:
        logger.error(f"[_quick_scan_local] å¤±è´¥: {e}")
        return {"ports": [], "scan_time": 0, "error": str(e)}


# ==================== å·¥ä½œæµåˆ›å»º ====================

def create_security_scan_graph(checkpointer=None):
    """
    åˆ›å»ºå®‰å…¨æ‰«æå·¥ä½œæµå›¾
    
    Args:
        checkpointer: LangGraph checkpointer (Redis/Postgres)
    
    Returns:
        Compiled graph
    """
    # åˆ›å»ºå·¥ä½œæµ
    workflow = StateGraph(ScanState)
    
    # æ·»åŠ èŠ‚ç‚¹
    workflow.add_node("init", node_init)
    workflow.add_node("ping", node_ping)
    workflow.add_node("quick_scan", node_quick_scan)
    workflow.add_node("dispatch_full_scan", node_dispatch_full_scan)
    workflow.add_node("poll", node_poll)
    
    # è®¾ç½®å…¥å£
    workflow.set_entry_point("init")
    
    # æ·»åŠ è¾¹
    workflow.add_edge("init", "ping")
    
    # Ping æˆåŠŸ â†’ å¿«é€Ÿæ‰«æï¼Œå¤±è´¥ â†’ ç»“æŸ
    workflow.add_conditional_edges(
        "ping",
        lambda state: "quick_scan" if is_ping_successful(state) else END,
        {
            "quick_scan": "quick_scan",
            "end": END
        }
    )
    
    # å¿«é€Ÿæ‰«æ â†’ åˆ†å‘ä»»åŠ¡
    workflow.add_edge("quick_scan", "dispatch_full_scan")
    
    # åˆ†å‘ä»»åŠ¡ â†’ è½®è¯¢
    workflow.add_conditional_edges(
        "dispatch_full_scan",
        lambda state: "poll" if should_poll(state) else END,
        {
            "poll": "poll",
            "end": END
        }
    )
    
    # è½®è¯¢ â†’ ç»§ç»­è½®è¯¢ æˆ– ç»“æŸ
    workflow.add_conditional_edges(
        "poll",
        should_continue_polling,
        {
            "poll": "poll",
            "end": END
        }
    )
    
    # ç¼–è¯‘å·¥ä½œæµ
    return workflow.compile(checkpointer=checkpointer)


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

async def run_scan_with_graph(
    target: str,
    user_id: Optional[str] = None,
    thread_id: Optional[str] = None,
):
    """
    ä½¿ç”¨ LangGraph å·¥ä½œæµæ‰§è¡Œæ‰«æ
    
    Args:
        target: æ‰«æç›®æ ‡
        user_id: ç”¨æˆ·ID
        thread_id: çº¿ç¨‹IDï¼ˆç”¨äºcheckpointæ¢å¤ï¼‰
        
    Returns:
        æœ€ç»ˆçŠ¶æ€
    """
    # åˆ›å»º checkpointerï¼ˆä½¿ç”¨ Redisï¼‰
    from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
    
    # æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ MemorySaver ä½œä¸ºç¤ºä¾‹ï¼Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨ Redis
    from langgraph.checkpoint.memory import MemorySaver
    checkpointer = MemorySaver()
    
    # åˆ›å»ºå·¥ä½œæµ
    graph = create_security_scan_graph(checkpointer)
    
    # åˆå§‹çŠ¶æ€
    initial_state: ScanState = {
        "target": target,
        "user_id": user_id,
        "ping_result": None,
        "quick_scan_result": None,
        "full_scan_result": None,
        "current_stage": "init",
        "background_tasks": {},
        "progress": 0,
        "progress_messages": [],
        "final_result": None,
        "error": None,
    }
    
    # é…ç½®
    config = RunnableConfig(
        configurable={"thread_id": thread_id or str(uuid.uuid4())}
    )
    
    # æ‰§è¡Œå·¥ä½œæµ
    async for event in graph.astream(initial_state, config):
        logger.info(f"[Graph Event] {event}")
        # å¯ä»¥åœ¨è¿™é‡Œæ¨é€ SSE äº‹ä»¶
    
    # è·å–æœ€ç»ˆçŠ¶æ€
    final_state = await graph.ainvoke(initial_state, config)
    
    return final_state
